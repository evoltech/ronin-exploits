#
# Ronin Exploits - A Ruby library for Ronin that provides exploitation and
# payload crafting functionality.
#
# Copyright (c) 2007-2011 Hal Brodigan (postmodern.mod3 at gmail.com)
#
# This file is part of Ronin Exploits.
#
# Ronin is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ronin is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ronin.  If not, see <http://www.gnu.org/licenses/>
#

require 'ronin/ui/cli/script_command'
require 'ronin/ui/console'
require 'ronin/exploits'
require 'ronin/payloads'
require 'ronin/database'

module Ronin
  module UI
    module CLI
      module Commands
        class Exploit < ScriptCommand

          desc 'Builds and deploys an exploit'

          script_class Ronin::Exploits::Exploit

          # exploit options
          class_option :host, :type => :string
          class_option :port, :type => :numeric
          class_option :local_host, :type => :string
          class_option :local_port, :type => :numeric
          class_option :dry_run, :type => :boolean, :default => false
          class_option :raw_payload, :type => :string

          # target options
          class_option :target, :type => :numeric, :alias => '-t'
          class_option :target_arch, :type => :string, :aliases => '-a'
          class_option :target_os, :type => :string, :aliases => '-o'
          class_option :target_software, :type => :string
          class_option :target_version, :type => :string

          # payload options
          class_option :payload_name, :type => :string,
                                      :aliases => '--payload -P'
          class_option :payload_version, :type => :string
          class_option :payload_file, :type => :string

          # post-exploit options
          class_option :shell_console, :type => :boolean, :default => false
          class_option :fs_console, :type => :boolean, :default => false

          def execute
            unless (@exploit = load_script)
              print_error "Could not find the specified exploit"
              exit -1
            end

            select_target!
            select_payload!

            params = options[:params]
            params[:host] = options[:host] if options[:host]
            params[:port] = options[:port] if options[:port]
            params[:local_host] = options[:local_host] if options[:local_host]
            params[:local_port] = options[:local_port] if options[:local_port]
            params[:dry_run] = options.dry_run?

            begin
              @exploit.exploit!(params)
            rescue Script::Exception,
                   Exploits::Exception,
                   Payloads::Exception => error
              print_error error.message
              exit -1
            end

            if options.shell_console?
              if @exploit.leverages?(:shell)
                @exploit.shell.console
              else
                print_error "The exploit does not leverage the shell"
              end
            elsif options.fs_console?
              if @exploit.leverages?(:fs)
                @exploit.fs.console
              else
                print_error "The exploit does not leverage the file system"
              end
            elsif options.console?
              print_info 'Starting the console with @exploit set ...'

              UI::Console.start(:exploit => @exploit)
            end

            @exploit.evaucate!
          end

          protected

          def load_payload!
            unless @exploit.use_payload_from!(options[:payload_file])
              print_error "Could not load a compatible payload for the exploit!"
            end
          end

          def find_payload!
            @exploit.use_payload! do |payloads|
              if options[:payload_name]
                payloads = payloads.named(options[:payload_name])
              end

              if options[:payload_version]
                payloads = payloads.revision(options[:payload_version])
              end

              payloads
            end

            unless @exploit.payload
              print_error "Could not find a compatible payload for the exploit!"
              exit -1
            end
          end

          def select_target!
            if options[:target]
              unless @exploit.use_target!(options[:target])
                print_error "Invalid target index: #{options[:target]}"
                exit -1
              end
            elsif (options[:target_arch] || options[:target_os] ||
                   options[:target_software] || options[:target_version])
              @exploit.use_target! do |target|
                if (options[:target_arch] && target.arch)
                  next unless target.arch.name == options[:target_arch]
                end

                if (options[:target_os] && target.os)
                  next unless target.os.name == options[:target_os]
                end

                if (options[:target_software] && target.software)
                  next unless target.software.name.include?(options[:target_software])
                end

                if (options[:target_version] && target.software)
                  next unless target.software.version == options[:target_version]
                end

                true
              end
            end

          end

          def select_payload!
            if options[:raw_payload]
              @exploit.raw_payload = options[:raw_payload]
            elsif options[:payload_file]
              load_payload!
            elsif options[:payload_name]
              find_payload!
            end
          end

        end
      end
    end
  end
end
