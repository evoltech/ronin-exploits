#
# Ronin - A decentralized repository for the storage and sharing of computer
# security advisories, exploits and payloads.
#
# Copyright (c) 2007 Hal Brodigan (postmodern at users.sourceforge.net)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

require 'ronin/exploits/exploitauthor'
require 'ronin/exploits/exceptions/exploitnotbuilt'
require 'ronin/vuln/vulnerability'
require 'ronin/parameters'
require 'ronin/license'

require 'og'
require 'yaml'

module Ronin
  module Exploits
    class Exploit

      include Parameters

      # Name of the specific exploit
      attr_accessor :name, String

      # Version of the exploit
      attr_accessor :version, String

      # Description of the exploit
      attr_accessor :description, String

      # Restricted pattern that may not occurr in the built exploit
      attr_accessor :restricted

      # Restricted characters that may not occurr in the built exploit
      attr_accessor :restricted_chars

      # Packaged exploit
      attr_reader :package

      # Vulnerability description
      has_many :vuln, Vuln::Vulnerability

      # Author(s) of the exploit
      has_many :authors, ExploitAuthor

      # Content license
      has_one :license, License

      schema_inheritance

      # String to pad extra space with
      parameter :pad, :value => 'A', :description => 'padding string'

      # Exploit payload
      parameter :payload, :description => 'exploit payload'

      def initialize(name=nil,version=nil,&block)
        super()

        @name = name
        @version = version
        @restricted = []
        @restricted_chars = []

        instance_eval(&block) if block
      end

      def author(name=ANONYMOUSE,info={:organization=> nil, :pgp_signature => nil, :address => nil, :phone => nil, :email => nil, :site => nil, :biography => nil},&block)
        self.authors << ExploitAuthor.new(name,info,&block)
      end

      def pad_buffer(padding,length)
        padding = padding.to_s

        buffer = padding*(length/padding.length)
        pad_remaining = (length % padding.length)

        buffer += padding[0,pad_remaining] unless pad_remaining==0
        return buffer
      end

      def restrict(*patterns)
        @restricted += patterns.map { |pattern| Regexp.new(pattern) }
      end

      def restrict_chars(*chars)
        @restricted_chars += chars
      end

      def builder
      end

      def import(file)
        @package = YAML::load(file)
      end

      def import_raw(file)
        File.open(file,'rb') do |file|
          @package = file.read
        end
      end

      def export(file)
        YAML::dump(@package,file)
      end

      def export_raw(file)
        File.open(file,'wb') do |file|
          file.write(@package)
        end
      end

      def is_built?
        !(@package.nil? || @package.empty?)
      end

      def build
        @package = ''

        builder

        if @package
          @restricted_chars.each do |chr|
            if @package.include?(chr)
              raise(RestrictedText,"Restricted character '#{chr}' was found in the built exploit",caller)
            end
          end

          @restricted.each do |pattern|
            if @package =~ pattern
              raise(RestrictedText,"Restricted pattern '#{pattern.source}' was found in the built exploit",caller)
            end
          end
        end

        return @package
      end

      def cleaner
      end

      def is_clean?
        @package.nil?
      end

      def clean
        cleaner

        @package = nil
      end

      def transmitter
      end

      def transmit
        unless @package
          raise(ExploitNotBuilt,"cannot transmit an unbuilt exploit",caller)
        end

        return transmitter
      end

      def exploit
        build
        transmit
        clean
      end

      def to_s
        if @version
          return "#{@name}-#{@version}"
        else
          return @name.to_s
        end
      end

    end
  end
end
